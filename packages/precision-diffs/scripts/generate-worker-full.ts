import { writeFileSync } from 'fs';
import { dirname, join } from 'path';
import { bundledLanguagesInfo } from 'shiki/bundle/full';
import { bundledThemesInfo } from 'shiki/bundle/full';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

function toImportName(id: string): string {
  return id.replace(/-/g, '_').replace(/\+/g, 'plus').replace(/^(\d)/, '_$1');
}

const langImports = bundledLanguagesInfo.map(
  (lang) =>
    `import lang_${toImportName(lang.id)} from '@shikijs/langs/${lang.id}';`
);

const themeImports = bundledThemesInfo.map(
  (theme) =>
    `import theme_${toImportName(theme.id)} from '@shikijs/themes/${theme.id}';`
);

const langArray = bundledLanguagesInfo.map(
  (lang) => `lang_${toImportName(lang.id)}`
);
const themeArray = bundledThemesInfo.map(
  (theme) => `theme_${toImportName(theme.id)}`
);

const output = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-worker-full.ts

import { createHighlighterCore } from 'shiki/core';
import { createJavaScriptRegexEngine } from 'shiki/engine/javascript';

${langImports.join('\n')}

${themeImports.join('\n')}

import pierreDark from '../themes/pierre-dark.json';
import pierreLight from '../themes/pierre-light.json';
import { DEFAULT_THEMES } from '../constants';
import type {
  PJSHighlighter,
  SupportedLanguages,
  ThemedDiffResult,
  ThemedFileResult,
  ThemeRegistrationResolved,
} from '../types';
import { getFiletypeFromFileName } from '../utils/getFiletypeFromFileName';
import { getThemes } from '../utils/getThemes';
import { renderDiffWithHighlighter } from '../utils/renderDiffWithHighlighter';
import { renderFileWithHighlighter } from '../utils/renderFileWithHighlighter';
import type {
  InitializeSuccessResponse,
  InitializeWorkerRequest,
  RegisterThemeWorkerRequest,
  RenderDiffMetadataRequest,
  RenderDiffMetadataSuccessResponse,
  RenderErrorResponse,
  RenderFileRequest,
  RenderFileSuccessResponse,
  WorkerRequest,
  WorkerRequestId,
} from './types';

const ALL_LANGS = [
  ${langArray.join(',\n  ')},
];

const ALL_THEMES = [
  ${themeArray.join(',\n  ')},
  pierreDark as ThemeRegistrationResolved,
  pierreLight as ThemeRegistrationResolved,
];

type PJSThemeNames = string;

type CachedOrLoadingHighlighterType =
  | Promise<PJSHighlighter>
  | PJSHighlighter
  | undefined;

let highlighter: CachedOrLoadingHighlighterType;

const loadedThemes = new Map<string, true | Promise<void>>();
const loadedLanguages = new Map<SupportedLanguages, true | Promise<void>>();

interface HighlighterOptions {
  themes: PJSThemeNames[];
  langs: SupportedLanguages[];
}

const CustomThemes = new Map<
  string,
  ThemeRegistrationResolved | (() => Promise<ThemeRegistrationResolved>)
>();

CustomThemes.set('pierre-dark', pierreDark as ThemeRegistrationResolved);
CustomThemes.set('pierre-light', pierreLight as ThemeRegistrationResolved);

function registerResolvedTheme(
  themeName: string,
  themeData: ThemeRegistrationResolved
): void {
  if (CustomThemes.has(themeName)) {
    return;
  }
  CustomThemes.set(themeName, themeData);
}

async function getSharedHighlighter({
  themes,
  langs,
}: HighlighterOptions): Promise<PJSHighlighter> {
  if (highlighter == null) {
    highlighter = new Promise((resolve) => {
      void (async () => {
        const themesToLoad: (
          | PJSThemeNames
          | ThemeRegistrationResolved
          | Promise<ThemeRegistrationResolved>
        )[] = [];
        for (const theme of themes) {
          loadedThemes.set(theme, true);
          const customTheme = CustomThemes.get(theme);
          if (customTheme != null) {
            if (typeof customTheme === 'function') {
              themesToLoad.push(customTheme());
            } else {
              themesToLoad.push(customTheme);
            }
          } else {
            themesToLoad.push(theme);
          }
        }
        for (const language of langs) {
          loadedLanguages.set(language, true);
        }
        loadedLanguages.set('text', true);
        const instance = (await createHighlighterCore({
          themes: ALL_THEMES,
          langs: ALL_LANGS,
          langAlias: {
            zsh: 'bash',
            sh: 'bash',
          },
          engine: createJavaScriptRegexEngine(),
        })) as PJSHighlighter;
        highlighter = instance;
        resolve(instance);
      })();
    });
    return highlighter;
  }
  const instance =
    'then' in highlighter ? await highlighter : highlighter;
  const loaders: Promise<void>[] = [];
  for (const language of langs) {
    const loadedOrLoading = loadedLanguages.get(language);
    if (loadedOrLoading == null) {
      loadedLanguages.set(language, true);
    } else if (loadedOrLoading !== true) {
      loaders.push(loadedOrLoading);
    }
  }
  for (const themeName of themes) {
    const loadedOrLoading = loadedThemes.get(themeName);
    if (loadedOrLoading == null) {
      loadedThemes.set(themeName, true);
    } else if (loadedOrLoading !== true) {
      loaders.push(loadedOrLoading);
    }
  }
  if (loaders.length > 0) {
    await Promise.all(loaders);
  }
  return instance;
}

self.addEventListener('error', (event) => {
  console.error('[Worker Full] Unhandled error:', event.error);
});

// eslint-disable-next-line @typescript-eslint/no-misused-promises
self.addEventListener('message', async (event: MessageEvent<WorkerRequest>) => {
  const request = event.data;

  try {
    switch (request.type) {
      case 'initialize':
        await handleInitialize(request);
        break;
      case 'register-theme':
        handleRegisterTheme(request);
        break;
      case 'file':
        await handleRenderFile(request);
        break;
      case 'diff':
        await handleRenderDiffMetadata(request);
        break;
      default:
        throw new Error(
          \`Unknown request type: \${(request as WorkerRequest).type}\`
        );
    }
  } catch (error) {
    console.error('Worker error:', error);
    sendError(request.id, error);
  }
});

async function handleInitialize({
  id,
  options,
  customThemes,
}: InitializeWorkerRequest) {
  if (customThemes != null) {
    for (const { name, data } of customThemes) {
      if (data != null) {
        registerResolvedTheme(name, data);
      }
    }
  }
  const langs = new Set(options?.langs);
  langs.add('text');
  await getSharedHighlighter({
    themes: getThemes(options.theme),
    langs: Array.from(langs),
  });
  postMessage({
    type: 'success',
    id,
    requestType: 'initialize',
    sentAt: Date.now(),
  } satisfies InitializeSuccessResponse);
}

function handleRegisterTheme({ id, themes }: RegisterThemeWorkerRequest) {
  for (const { name, data } of themes) {
    if (data != null) {
      registerResolvedTheme(name, data);
    }
  }
  postMessage({
    type: 'success',
    id,
    requestType: 'register-theme',
    sentAt: Date.now(),
  });
}

async function handleRenderFile({
  id,
  file,
  options: {
    theme = DEFAULT_THEMES,
    lang = getFiletypeFromFileName(file.name),
    startingLineNumber,
    tokenizeMaxLineLength,
  },
}: RenderFileRequest): Promise<void> {
  sendFileSuccess(
    id,
    renderFileWithHighlighter(file, await getHighlighter(lang, theme), {
      theme,
      lang,
      startingLineNumber,
      tokenizeMaxLineLength,
    })
  );
}

async function handleRenderDiffMetadata({
  id,
  options,
  diff,
}: RenderDiffMetadataRequest) {
  const { lang } = options ?? {};
  const oldLang = lang ?? getFiletypeFromFileName(diff.prevName ?? diff.name);
  const newLang = lang ?? getFiletypeFromFileName(diff.name);
  const highlighter = await getHighlighter([oldLang, newLang], options?.theme);
  const result = renderDiffWithHighlighter(diff, highlighter, options);
  sendDiffMetadataSuccess(id, result);
}

async function getHighlighter(
  lang: SupportedLanguages | SupportedLanguages[],
  theme: string | Record<'dark' | 'light', string> = DEFAULT_THEMES
): Promise<PJSHighlighter> {
  const filteredLangs = new Set(!Array.isArray(lang) ? [lang] : lang);
  filteredLangs.add('text');
  return await getSharedHighlighter({
    themes: getThemes(theme),
    langs: Array.from(filteredLangs),
  });
}

function sendFileSuccess(id: WorkerRequestId, result: ThemedFileResult) {
  postMessage({
    type: 'success',
    requestType: 'file',
    id,
    result,
    sentAt: Date.now(),
  } satisfies RenderFileSuccessResponse);
}

function sendDiffMetadataSuccess(
  id: WorkerRequestId,
  result: ThemedDiffResult
) {
  postMessage({
    type: 'success',
    requestType: 'diff',
    id,
    result,
    sentAt: Date.now(),
  } satisfies RenderDiffMetadataSuccessResponse);
}

function sendError(id: WorkerRequestId, error: unknown) {
  const response: RenderErrorResponse = {
    type: 'error',
    id,
    error: error instanceof Error ? error.message : String(error),
    stack: error instanceof Error ? error.stack : undefined,
  };
  postMessage(response);
}
`;

const outPath = join(__dirname, '../src/worker/worker-full.ts');
writeFileSync(outPath, output);
console.log(`Generated ${outPath}`);
