## Overview

<Notice variant="warning" icon={<IconCiWarningFill />}>
  Diffs is in early active development—APIs are subject to change.
</Notice>

**Diffs** is a library for rendering code and diffs on the web. This includes both high-level, easy-to-use components, as well as exposing many of the internals if you want to selectively use specific pieces. We've built syntax highlighting on top of [Shiki](https://shiki.style/) which provides a lot of great theme and language support.

<MultiFileDiff
  {...initialDiffProps}
  className="overflow-hidden rounded-md border-1"
/>

We have an opinionated stance in our architecture: **browsers are rather efficient at rendering raw HTML**. We lean into this by having all the lower level APIs purely rendering strings (the raw HTML) that are then consumed by higher-order components and utilities. This gives us great performance and flexibility to support popular libraries like React as well as provide great tools if you want to stick to vanilla JavaScript and HTML. The higher-order components render all this out into Shadow DOM and CSS grid layout.

Generally speaking, you're probably going to want to use the higher level components since they provide an easy-to-use API that you can get started with rather quickly. We currently only have components for vanilla JavaScript and React, but will add more if there's demand.

For this overview, we'll talk about the vanilla JavaScript components for now but there are React equivalents for all of these.

## Rendering diffs

Our goal with visualizing diffs was to provide some flexible and approachable APIs for _how_ you may want to render diffs. For this, we provide a component called `FileDiff`.

There are two ways to render diffs with `FileDiff`:

1. Provide two versions of a file or code snippet to compare
2. Consume a patch file

You can see examples of these approaches below, in both JavaScript and React.

<OverviewExample
  initialDiffProps={initialDiffProps}
  reactSingleFile={reactSingleFile}
  reactPatchFile={reactPatchFile}
  vanillaSingleFile={vanillaSingleFile}
  vanillaPatchFile={vanillaPatchFile}
/>

## Installation

Diffs is [published as an npm package](https://www.npmjs.com/package/@pierre/precision-diffs). Install Diffs with the package manager of your choice:

<InstallationSelector installationExamples={installationExamples} />

### Package Exports

The package provides several entry points for different use cases:

| Package                          | Description                                                                                                  |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| `@pierre/precision-diffs`        | [Vanilla JS components](#vanilla-js-api) and [utility functions](#utilities) for parsing and rendering diffs |
| `@pierre/precision-diffs/react`  | [React components](#react-api) for rendering diffs with full interactivity                                   |
| `@pierre/precision-diffs/ssr`    | [Server-side rendering utilities](#ssr) for pre-rendering diffs with syntax highlighting                     |
| `@pierre/precision-diffs/worker` | [Worker pool utilities](#worker-pool) for offloading syntax highlighting to background threads               |

## React API

<Notice icon={<IconInfoFill />}>
  Import React components from `@pierre/precision-diffs/react`.
</Notice>

We offer a variety of components to render diffs and files. Many of them share similar types of props, which you can find documented in [Shared Props](#react-api-shared-props).

### Components

The React API exposes four main components:

- `MultiFileDiff` compares two file versions
- `PatchDiff` renders from a patch string
- `FileDiff` renders a pre-parsed `FileDiffMetadata`
- `File` renders a single code file without a diff

<ReactAPIExample
  reactAPIMultiFileDiff={reactAPIMultiFileDiff}
  reactAPIPatch={reactAPIPatch}
  reactAPIFileDiff={reactAPIFileDiff}
  reactAPIFile={reactAPIFile}
/>

### Shared Props

The three diff components (`MultiFileDiff`, `PatchDiff`, and `FileDiff`) share a common set of props for configuration, annotations, and styling. The `File` component has similar props, but uses `LineAnnotation` instead of `DiffLineAnnotation` (no `side` property).

<ReactAPISharedProps
  sharedDiffOptions={sharedDiffOptions}
  sharedDiffRenderProps={sharedDiffRenderProps}
  sharedFileOptions={sharedFileOptions}
  sharedFileRenderProps={sharedFileRenderProps}
/>

## Vanilla JS API

<Notice icon={<IconInfoFill />}>
  Import vanilla JavaScript classes, components, and methods from
  `@pierre/precision-diffs`.
</Notice>

### Components

The Vanilla JS API exposes two core components: `FileDiff` (compare two file versions or render a pre-parsed `FileDiffMetadata`) and `File` (render a single code file without diff). Typically you'll want to interface with these as they'll handle all the complicated aspects of syntax highlighting, theming, and full interactivity for you.

<VanillaAPIComponents
  fileDiffExample={fileDiffExample}
  fileExample={fileExample}
/>

### Props

Both `FileDiff` and `File` accept an options object in their constructor. The `File` component has similar options, but excludes diff-specific settings and uses `LineAnnotation` instead of `DiffLineAnnotation` (no `side` property).

<VanillaAPIPropsExample fileDiffProps={fileDiffProps} fileProps={fileProps} />

#### Custom Hunk Separators

If you want to render custom hunk separators that won't scroll with the content, there are a few tricks you will need to employ. See the following code snippet:

<DocsCodeExample {...customHunk} />

### Renderers

<Notice icon={<IconInfoFill />}>
  For most use cases, you should use the higher-level components like `FileDiff`
  and `File` (vanilla JS) or the React components (`MultiFileDiff`, `FileDiff`,
  `PatchDiff`, `File`). These renderers are low-level building blocks intended
  for advanced use cases.
</Notice>

These renderer classes handle the low-level work of parsing and rendering code with syntax highlighting. Useful when you need direct access to the rendered output as [HAST](https://github.com/syntax-tree/hast) nodes or HTML strings for custom rendering pipelines.

#### DiffHunksRenderer

Takes a `FileDiffMetadata` data structure and renders out the raw HAST (Hypertext Abstract Syntax Tree) elements for diff hunks. You can generate `FileDiffMetadata` via `parseDiffFromFile` or `parsePatchFiles` utility functions.

<VanillaAPIDiffHunks
  diffHunksRenderer={diffHunksRenderer}
  diffHunksRendererPatch={diffHunksRendererPatch}
/>

#### FileRenderer

Takes a `FileContents` object (just a filename and contents string) and renders syntax-highlighted code as HAST elements. Useful for rendering single files without any diff context.

<DocsCodeExample {...fileRenderer} />

## Utilities

<Notice icon={<IconInfoFill />}>
  Import utility functions from `@pierre/precision-diffs`. These can be used
  with any framework or rendering approach.
</Notice>

### diffAcceptRejectHunk

Programmatically accept or reject individual hunks in a diff. This is useful for building interactive code review interfaces, AI-assisted coding tools, or any workflow where users need to selectively apply changes.

<UtilitiesAcceptReject
  diffAcceptReject={diffAcceptReject}
  diffAcceptRejectReact={diffAcceptRejectReact}
/>

### parseDiffFromFile

Parse two file versions into a `FileDiffMetadata` structure containing hunks and line-level changes.

<DocsCodeExample {...parseDiffFromFile} />

### parsePatchFiles

Parse a unified diff patch string (like from `git diff`) into an array of `FileDiffMetadata` objects.

<DocsCodeExample {...parsePatchFiles} />

### getSharedHighlighter

Access the singleton Shiki highlighter instance used by the library. Useful when you need direct access to the highlighter for advanced use cases.

<DocsCodeExample {...getSharedHighlighter} />

### preloadHighlighter

Pre-initialize the Shiki highlighter with specific themes and languages before rendering. This can improve initial render performance by loading syntax highlighting assets upfront.

<DocsCodeExample {...preloadHighlighter} />

### disposeHighlighter

Clean up and dispose of the Shiki highlighter instance to free memory. Call this when you're done rendering diffs and want to clean up resources.

<DocsCodeExample {...disposeHighlighter} />

### registerCustomTheme

Register a custom Shiki theme that can be used with diff and file components. Useful when you want to match your application's design system.

<DocsCodeExample {...registerCustomTheme} />

## Styling

Diff and code components are rendered using shadow DOM APIs, allowing styles to be well-isolated from your page's existing CSS. However, it also means you may have to utilize some custom CSS variables to override default styles. These can be done in your global CSS, as style props on parent components, or on the `FileDiff` component directly.

<DocsCodeExample {...stylingGlobal} />

<DocsCodeExample {...stylingInline} />

### Advanced: Unsafe CSS

For advanced customization, you can inject arbitrary CSS into the shadow DOM using the `unsafeCSS` option. This CSS will be wrapped in an `@layer unsafe` block, giving it the highest priority in the cascade. Use this sparingly and with caution, as it bypasses the normal style isolation.

We also recommend that any CSS you apply uses simple, direct selectors targeting the existing data attributes. Avoid structural selectors like `:first-child`, `:last-child`, `:nth-child()`, sibling combinators (`+` or `~`), deeply nested descendant selectors, or bare tag selectors—these are susceptible to breaking in future versions or in edge cases that may be difficult to anticipate.

<Notice variant="warning" icon={<IconCiWarningFill />}>
  We cannot currently guarantee backwards compatibility for this feature across
  any future changes to the library, even in patch versions. Please reach out so
  that we can discuss a more permanent solution for modifying styles.
</Notice>

<DocsCodeExample {...stylingUnsafe} />

## Worker Pool

<Notice icon={<IconInfoFill />}>
  Import worker utilities from `@pierre/precision-diffs/worker`.
</Notice>

By default, syntax highlighting runs on the main thread using Shiki. If you're rendering large files or many diffs, this can cause a bottleneck on your JavaScript thread resulting in jank or unresponsiveness. To work around this, we've provided some APIs to run all syntax highlighting in worker threads. The main thread will still attempt to render plain text synchronously and then apply the syntax highlighting when we get a response from the worker threads.

Basic usage differs a bit depending on if you're using React or Vanilla JS APIs, so continue reading for more details.

### Setup

One unfortunate side effect of using Web Workers is that different bundlers and environments require slightly different approaches to create a Web Worker. You'll need to create a function that spawns a worker that's appropriate for your environment and bundler and then pass that function to our provided APIs.

Lets begin with the `workerFactory` function. We've provided some examples for common use cases below.

<Notice variant="warning" icon={<IconCiWarningFill />}>
  Only the Vite and NextJS examples have been tested by us. Additional examples
  were generated by AI. If any of them are incorrect, please let us know.
</Notice>

#### Vite

You may need to explicitly set the `worker.format` option in your [Vite Config](https://vite.dev/config/worker-options#worker-format) to `'es'`.

<DocsCodeExample {...helperVite} />

#### NextJS

<Notice variant="warning" icon={<IconCiWarningFill />}>
  Workers only work in client components. Ensure your function has the `'use
  client'` directive if using App Router.
</Notice>

<DocsCodeExample {...helperNextJS} />

#### Webpack 5

<DocsCodeExample {...helperWebpack} />

#### esbuild

<DocsCodeExample {...helperESBuild} />

#### Rollup / Static Files

If your bundler doesn't have special worker support, build and serve the worker file statically:

<DocsCodeExample {...helperStatic} />

#### Vanilla JS (No Bundler)

For projects without a bundler, host the worker file on your server and reference it directly:

<DocsCodeExample {...helperVanilla} />

### Usage

With your `workerFactory` function created, you can integrate it with our provided APIs. In React, you'll want to pass this `workerFactory` to a `<WorkerPoolContextProvider>` so all components can inherit the pool automatically. If you're using the Vanilla JS APIs, we provide a `getOrCreateWorkerPoolSingleton` helper that ensures a single pool instance that you can then manually pass to all your File/FileDiff instances.

<Notice icon={<IconInfoFill />}>
  When using the worker pool, theme settings are controlled by the pool manager,
  not individual component Any `theme` options passed to `File` or `FileDiff`
  components will be ignored. To change the theme, use the `setTheme()` method
  on the pool manager. All connected instances will automatically re-render with
  the new theme.
</Notice>

#### React

Wrap your component tree with `WorkerPoolContextProvider` from `@pierre/precision-diffs/react`. All `FileDiff` and `File` components nested within will automatically use the worker pool for syntax highlighting.

The `WorkerPoolContextProvider` will automatically spin up or shut down the worker pool based on its react lifecycle. If you have multiple context providers, they will all share the same pool, and termination won't occur until all contexts are unmounted.

<Notice variant="warning" icon={<IconCiWarningFill />}>
  Workers only work in client components. Ensure your function has the `'use
  client'` directive if using App Router.
</Notice>

To change themes dynamically, use the `useWorkerPool()` hook to access the pool manager and call `setTheme()`.

<DocsCodeExample {...reactUsage} />

#### Vanilla JS

Use `getOrCreateWorkerPoolSingleton` to spin up a singleton worker pool. Then pass that as the second argument to `File` and/or `FileDiff`. When you are done with the worker pool, you can use `terminateWorkerPoolSingleton` to free up resources.

To change themes dynamically, call `workerPool.setTheme(theme)` on the pool instance.

<DocsCodeExample {...vanillaUsage} />

### API Reference

These methods are exposed for advanced use cases. In most scenarios, you should use the `WorkerPoolContextProvider` for React or pass the pool instance via the `workerPool` option for Vanilla JS rather than calling these methods directly.

<DocsCodeExample {...apiReference} />

### Architecture

The worker pool manages a configurable number of worker threads that each initialize their own Shiki highlighter instance. Tasks are distributed across available workers, with queuing when all workers are busy.

<DocsCodeExample
  {...architectureASCII}
  className="inline-block"
  style={{
    '--pjs-line-height': '15px',
  }}
/>

## SSR

<Notice icon={<IconInfoFill />}>
  Import SSR utilities from `@pierre/precision-diffs/ssr`.
</Notice>

The SSR API allows you to pre-render file diffs on the server with syntax highlighting, then hydrate them on the client for full interactivity.

### Usage

Each preload function returns an object containing the original inputs plus a `prerenderedHTML` string. This object can be spread directly into the corresponding React component for automatic hydration.

<Notice variant="warning" icon={<IconCiWarningFill />}>
  Inputs used for pre-rendering must exactly match what's rendered in the client
  component. We recommend spreading the entire result object into your File or
  Diff component to ensure the client receives the same inputs that were used to
  generate the pre-rendered HTML.
</Notice>

#### Server Component

<DocsCodeExample {...usageServer} />

#### Client Component

<DocsCodeExample {...usageClient} />

### Preloaders

We provide several preload functions to handle different input formats. Choose the one that matches your data source.

#### preloadFile

Preloads a single file with syntax highlighting (no diff). Use this when you want to render a file without any diff context. Spread into the `File` component.

<DocsCodeExample {...preloadFile} />

#### preloadFileDiff

Preloads a diff from a `FileDiffMetadata` object. Use this when you already have parsed diff metadata (e.g., from `parseDiffFromFile` or `parsePatchFiles`). Spread into the `FileDiff` component.

<DocsCodeExample {...preloadFileDiff} />

#### preloadMultiFileDiff

Preloads a diff directly from old and new file contents. This is the simplest option when you have the raw file contents and want to generate a diff. Spread into the `MultiFileDiff` component.

<DocsCodeExample {...preloadMultiFileDiff} />

#### preloadPatchDiff

Preloads a diff from a unified patch string for a single file. Use this when you have a patch in unified diff format. Spread into the `PatchDiff` component.

<DocsCodeExample {...preloadPatchDiff} />

#### preloadPatchFile

Preloads multiple diffs from a multi-file patch string. Returns an array of results, one for each file in the patch. Each result can be spread into a `FileDiff` component.

<DocsCodeExample {...preloadPatchFile} />
