'use client';

import {
  IconBulbFill,
  IconCiWarningFill,
  IconInfoFill,
} from '@/components/icons';
import { Notice } from '@/components/ui/notice';
import type { PreloadedFileResult } from '@pierre/precision-diffs/ssr';
import type { CSSProperties } from 'react';

import { DocsCodeExample } from '../DocsCodeExample';

interface WorkerPoolProps {
  helperVite: PreloadedFileResult<undefined>;
  helperNextJS: PreloadedFileResult<undefined>;
  vscodeLocalRoots: PreloadedFileResult<undefined>;
  vscodeWorkerUri: PreloadedFileResult<undefined>;
  vscodeInlineScript: PreloadedFileResult<undefined>;
  vscodeCsp: PreloadedFileResult<undefined>;
  vscodeGlobal: PreloadedFileResult<undefined>;
  vscodeBlobUrl: PreloadedFileResult<undefined>;
  vscodeFactory: PreloadedFileResult<undefined>;
  helperWebpack: PreloadedFileResult<undefined>;
  helperESBuild: PreloadedFileResult<undefined>;
  helperStatic: PreloadedFileResult<undefined>;
  helperVanilla: PreloadedFileResult<undefined>;
  vanillaUsage: PreloadedFileResult<undefined>;
  reactUsage: PreloadedFileResult<undefined>;
  apiReference: PreloadedFileResult<undefined>;
  cachingExample: PreloadedFileResult<undefined>;
  architectureASCII: PreloadedFileResult<undefined>;
}

export function WorkerPool({
  helperVite,
  helperNextJS,
  vscodeLocalRoots,
  vscodeWorkerUri,
  vscodeInlineScript,
  vscodeCsp,
  vscodeGlobal,
  vscodeBlobUrl,
  vscodeFactory,
  helperWebpack,
  helperESBuild,
  helperStatic,
  helperVanilla,
  vanillaUsage,
  reactUsage,
  apiReference,
  cachingExample,
  architectureASCII,
}: WorkerPoolProps) {
  return (
    <section className="space-y-4">
      <h2>Worker Pool</h2>
      <Notice icon={<IconBulbFill />}>
        Import worker utilities from <code>@pierre/precision-diffs/worker</code>
        .
      </Notice>
      <p>
        By default, syntax highlighting runs on the main thread using Shiki. If
        you’re rendering large files or many diffs, this can cause a bottleneck
        on your JavaScript thread resulting in jank or unresponsiveness. To work
        around this, we’ve provided some APIs to run all syntax highlighting in
        worker threads. The main thread will still attempt to render plain text
        synchronously and then apply the syntax highlighting when we get a
        response from the worker threads.
      </p>
      <p>
        Basic usage differs a bit depending on if you’re using React or Vanilla
        JS APIs, so continue reading for more details.
      </p>

      <h3>Setup</h3>
      <p>
        One unfortunate side effect of using Web Workers is that different
        bundlers and environments require slightly different approaches to
        create a Web Worker. You’ll need to create a function that spawns a
        worker that’s appropriate for your environment and bundler and then pass
        that function to our provided APIs.
      </p>
      <p>
        Lets begin with the <code>workerFactory</code> function. We’ve provided
        some examples for common use cases below.
      </p>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Only the Vite and NextJS examples have been tested by us. Additional
        examples were generated by AI. If any of them are incorrect, please let
        us know.
      </Notice>

      <h4 data-toc-ignore>Vite</h4>
      <p>
        You may need to explicitly set the <code>worker.format</code> option in
        your{' '}
        <a
          href="https://vite.dev/config/worker-options#worker-format"
          target="_blank"
          rel="noopener noreferrer"
        >
          Vite Config
        </a>{' '}
        to <code>'es'</code>.{' '}
      </p>
      <DocsCodeExample {...helperVite} />

      <h4 data-toc-ignore>NextJS</h4>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Workers only work in client components. Ensure your function has the{' '}
        <code>'use client'</code> directive if using App Router.
      </Notice>
      <DocsCodeExample {...helperNextJS} />

      <h4 data-toc-ignore>VS Code Webview Extension</h4>
      <p>
        VS Code webviews have special security restrictions that require a
        different approach. You’ll need to configure both the extension side (to
        expose the worker file) and the webview side (to load it via blob URL).
      </p>
      <p>
        <strong>Extension side:</strong> Add the worker directory to{' '}
        <code>localResourceRoots</code> in your <code>getWebviewOptions()</code>
        :
      </p>
      <DocsCodeExample {...vscodeLocalRoots} />
      <p>
        Create the worker URI in <code>_getHtmlForWebview()</code>. Note: use{' '}
        <code>worker-portable.js</code> instead of <code>worker.js</code> — the
        portable version is designed for environments where ES modules aren't
        supported in web workers.
      </p>
      <DocsCodeExample {...vscodeWorkerUri} />
      <p>Pass the URI to the webview via an inline script in your HTML:</p>
      <DocsCodeExample {...vscodeInlineScript} />
      <p>
        Your Content Security Policy must include <code>worker-src</code> and{' '}
        <code>connect-src</code>:
      </p>
      <DocsCodeExample {...vscodeCsp} />
      <p>
        <strong>Webview side:</strong> Declare the global type for the URI:
      </p>
      <DocsCodeExample {...vscodeGlobal} />
      <p>Fetch the worker code and create a blob URL:</p>
      <DocsCodeExample {...vscodeBlobUrl} />
      <p>
        Create the <code>workerFactory</code> function:
      </p>
      <DocsCodeExample {...vscodeFactory} />

      <h4 data-toc-ignore>Webpack 5</h4>
      <DocsCodeExample {...helperWebpack} />

      <h4 data-toc-ignore>esbuild</h4>
      <DocsCodeExample {...helperESBuild} />

      <h4 data-toc-ignore>Rollup / Static Files</h4>
      <p>
        If your bundler doesn’t have special worker support, build and serve the
        worker file statically:
      </p>
      <DocsCodeExample {...helperStatic} />

      <h4 data-toc-ignore>Vanilla JS (No Bundler)</h4>
      <p>
        For projects without a bundler, host the worker file on your server and
        reference it directly:
      </p>
      <DocsCodeExample {...helperVanilla} />

      <h3>Usage</h3>
      <p>
        With your <code>workerFactory</code> function created, you can integrate
        it with our provided APIs. In React, you’ll want to pass this{' '}
        <code>workerFactory</code> to a{' '}
        <code>&lt;WorkerPoolContextProvider&gt;</code> so all components can
        inherit the pool automatically. If you’re using the Vanilla JS APIs, we
        provide a <code>getOrCreateWorkerPoolSingleton</code> helper that
        ensures a single pool instance that you can then manually pass to all
        your File/FileDiff instances.
      </p>

      <Notice icon={<IconInfoFill />}>
        When using the worker pool, theme settings are controlled by the pool
        manager, not individual component props. Any <code>theme</code> options
        passed to <code>File</code> or <code>FileDiff</code> components will be
        ignored. To change the theme, use the <code>setTheme()</code> method on
        the pool manager. All connected instances will automatically re-render
        with the new theme.
      </Notice>

      <h4 data-toc-ignore>React</h4>
      <p>
        Wrap your component tree with <code>WorkerPoolContextProvider</code>{' '}
        from <code>@pierre/precision-diffs/react</code>. All{' '}
        <code>FileDiff</code> and <code>File</code> components nested within
        will automatically use the worker pool for syntax highlighting.
      </p>
      <p>
        The <code>WorkerPoolContextProvider</code> will automatically spin up or
        shut down the worker pool based on its react lifecycle. If you have
        multiple context providers, they will all share the same pool, and
        termination won’t occur until all contexts are unmounted.
      </p>

      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Workers only work in client components. Ensure your function has the{' '}
        <code>'use client'</code> directive if using App Router.
      </Notice>

      <p>
        To change themes dynamically, use the <code>useWorkerPool()</code> hook
        to access the pool manager and call <code>setTheme()</code>.
      </p>
      <DocsCodeExample {...reactUsage} />

      <h4 data-toc-ignore>Vanilla JS</h4>
      <p>
        Use <code>getOrCreateWorkerPoolSingleton</code> to spin up a singleton
        worker pool. Then pass that as the second argument to <code>File</code>{' '}
        and/or <code>FileDiff</code>. When you are done with the worker pool,
        you can use <code>terminateWorkerPoolSingleton</code> to free up
        resources.
      </p>
      <p>
        To change themes dynamically, call{' '}
        <code>workerPool.setTheme(theme)</code> on the pool instance.
      </p>
      <DocsCodeExample {...vanillaUsage} />

      <h3>Render Cache</h3>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        This is an experimental feature. It is disabled by default while being
        validated in production use cases.
      </Notice>
      <p>
        The worker pool can cache rendered AST results to avoid redundant
        highlighting work. When enabled, subsequent requests for the same file
        or diff will return cached results immediately instead of reprocessing
        through a worker. This works automatically for both React and Vanilla JS
        APIs — no additional code changes are required beyond enabling the
        option.
      </p>
      <Notice icon={<IconInfoFill />}>
        The cache uses <strong>referential equality</strong> to identify files
        and diffs. You must keep your <code>FileContents</code> and{' '}
        <code>FileDiffMetadata</code> objects stable (e.g., memoized or stored
        in state) rather than recreating them on every render. If you pass new
        object references each time, the cache will grow unexpectedly and
        provide no benefit.
      </Notice>
      <DocsCodeExample {...cachingExample} />

      <h3>API Reference</h3>
      <p>
        These methods are exposed for advanced use cases. In most scenarios, you
        should use the <code>WorkerPoolContextProvider</code> for React or pass
        the pool instance via the <code>workerPool</code> option for Vanilla JS
        rather than calling these methods directly.
      </p>
      <DocsCodeExample {...apiReference} />

      <h3>Architecture</h3>
      <p>
        The worker pool manages a configurable number of worker threads that
        each initialize their own Shiki highlighter instance. Tasks are
        distributed across available workers, with queuing when all workers are
        busy.
      </p>
      <DocsCodeExample
        {...architectureASCII}
        className="inline-block"
        style={
          {
            '--pjs-line-height': '15px',
          } as CSSProperties
        }
      />
    </section>
  );
}
